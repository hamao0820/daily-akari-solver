# cfs2（Constraint First Search）

## 概要
CFS は数字セルを「最も情報量の大きい変数」と見なし，そこから先に制約を消化することで枝刈りを効かせる探索です．Akari においては隣接する灯りの個数に制限がある数字セルが最も強い制約を持つため，それらを優先して処理し，照明を置くべき方向に絞り込んでから残りのセルを埋めていきます．

## データ構造と初期状態
### `Cell` と `TempFill`
- `Cell::Fillable` は灯りを置ける空セル，`Cell::Unfillable(bool)` は灯りを置けないセル（`bool` が `true` ならすでに照らされている），`Cell::Nil` は数字や壁で探索対象外．
- `TempFill` は `Cell` を使った補助的なグリッドで，あかりが置けない方向を履歴として持つことで，後の判断で使えるようにしています．

### 制約リスト
`solve` ではまず数字セルの座標を `constraints` ベクタに収集し，この順番で再帰的に処理します．残った空セルは `cell_pos` に沿って線形に埋めていきます．

## 再帰探索（`rec`）
1. すでに解が見つかったら打ち切り．
2. すべてのセルを走査し終えたときに `Solution` が矛盾なく満たされていれば解を確定．
3. `has_unfeasible_cell` で照らし手のないセルがないか確認し，あれば枝刈り．
4. `constraints` に使っていない数字が残っていれば，数字に応じた方向の組合せを試行：
   - `State::Adj0` ～ `Adj4` までの補助関数で `Cell` を `disable` して置けない方向をマークしつつ，必要な方向に灯りを置く．
   - `ADJ` （上下左右）を使って方向の組合せを列挙し，`put_akari` によって実際に灯りを配置する．
5. 制約がなくなったら，残りのセルを順番に「灯りを置く」「置かない」と試す．置けない場合は `fill[r][c].disable()` で記録しつつ次のセルへ．

## 補助処理
- `put_akari` は与えられた位置が `Fillable` か既に灯りなら処理し，4 方向に向かって照らしながら `fill` を `Unfillable(true)` に更新し，既存灯りとの重複（`OVERLAP_AKARI`）を検出します．
- `has_unfeasible_cell` は `Unfillable(false)` のセルが灯りを獲得できるような `Fillable` セルにつながっているかを確認し，つながりがないと枝刈りします．これは `ADJ` の方向に線分を伸ばしてチェックします．

## 実行結果と特徴
- 数字セルを先に全パターン試行することで，空セルを線形に試す部分の枝を大きく削る工夫が中心．
- `TempFill` に「この方向はもう駄目」という情報を残すことで，後続の再帰において無駄な可能性を排除．
- 基本的には深さ優先探索であり，最初に見つかった解を `found` に保持して再帰を打ち切ります．

このように CFS では強い制約から先に満たす単純な再帰を繰り返すことで，Akari のような局所制約の多いパズルを効率的に解きます．
